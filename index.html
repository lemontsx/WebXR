<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Ball Throwing</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
        }
        #enter-vr {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            font-size: 16px;
            background: #1a73e8;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #enter-vr:hover {
            background: #1557b0;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>WebXR Ball Throwing</strong><br>
        Press 'A' on right controller to spawn ball<br>
        Grab and throw for realistic physics<br>
        Speed displayed in MPH
    </div>
    <button id="enter-vr">Enter VR</button>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, xrSession;
        let controller1, controller2;
        let balls = [];
        let ground;
        const gravity = -9.8;
        const metersToMiles = 2.23694; // m/s to mph conversion
        
        // Controller state
        let gripPressed1 = false;
        let gripPressed2 = false;
        let lastPositions = new Map();
        let heldBalls = new Map();

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 3);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            scene.add(dirLight);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(50, 50);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
            ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            // Grid helper
            const grid = new THREE.GridHelper(50, 50, 0x000000, 0x000000);
            grid.material.opacity = 0.2;
            grid.material.transparent = true;
            scene.add(grid);

            // Controllers
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            controller1.addEventListener('squeezestart', () => gripPressed1 = true);
            controller1.addEventListener('squeezeend', () => gripPressed1 = false);
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            controller2.addEventListener('squeezestart', () => gripPressed2 = true);
            controller2.addEventListener('squeezeend', () => gripPressed2 = false);
            scene.add(controller2);

            // Controller visualizations
            const controllerGeo = new THREE.SphereGeometry(0.05, 16, 16);
            const controllerMat1 = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const controllerMat2 = new THREE.MeshStandardMaterial({ color: 0x0000ff });
            
            const grip1 = new THREE.Mesh(controllerGeo, controllerMat1);
            const grip2 = new THREE.Mesh(controllerGeo, controllerMat2);
            
            controller1.add(grip1);
            controller2.add(grip2);

            // VR Button
            document.getElementById('enter-vr').addEventListener('click', () => {
                if (navigator.xr) {
                    navigator.xr.requestSession('immersive-vr', {
                        requiredFeatures: ['local-floor']
                    }).then(onSessionStarted);
                } else {
                    alert('WebXR not supported in this browser');
                }
            });

            window.addEventListener('resize', onWindowResize);
        }

        function onSessionStarted(session) {
            xrSession = session;
            renderer.xr.setSession(session);
            
            session.addEventListener('inputsourceschange', (event) => {
                event.added.forEach((source) => {
                    if (source.handedness === 'right') {
                        source.gamepad?.buttons.forEach((button, i) => {
                            if (i === 4 || i === 5) { // A/X buttons
                                listenForAButton(source);
                            }
                        });
                    }
                });
            });
        }

        function listenForAButton(source) {
            const checkButton = () => {
                if (!xrSession) return;
                
                if (source.gamepad) {
                    // Button index 4 is typically 'A' on right controller
                    if (source.gamepad.buttons[4]?.pressed) {
                        spawnBall(controller2.position);
                    }
                }
                
                if (xrSession) {
                    setTimeout(checkButton, 100);
                }
            };
            checkButton();
        }

        function spawnBall(position) {
            const ballGeo = new THREE.SphereGeometry(0.1, 32, 32);
            const ballMat = new THREE.MeshStandardMaterial({ 
                color: Math.random() * 0xffffff,
                metalness: 0.3,
                roughness: 0.7
            });
            const ball = new THREE.Mesh(ballGeo, ballMat);
            
            ball.position.copy(position);
            ball.userData.velocity = new THREE.Vector3(0, 0, 0);
            ball.userData.isPhysics = true;
            ball.userData.held = false;
            
            scene.add(ball);
            balls.push(ball);
            
            // Limit number of balls
            if (balls.length > 20) {
                const oldBall = balls.shift();
                scene.remove(oldBall);
            }
        }

        function onSelectStart(event) {
            const controller = event.target;
            
            // Check if we can grab a nearby ball
            balls.forEach(ball => {
                if (!ball.userData.held) {
                    const dist = controller.position.distanceTo(ball.position);
                    if (dist < 0.15) {
                        ball.userData.held = true;
                        heldBalls.set(controller, ball);
                        lastPositions.set(controller, [
                            controller.position.clone(),
                            controller.position.clone(),
                            controller.position.clone()
                        ]);
                    }
                }
            });
        }

        function onSelectEnd(event) {
            const controller = event.target;
            const ball = heldBalls.get(controller);
            
            if (ball) {
                ball.userData.held = false;
                
                // Calculate throw velocity from recent positions
                const positions = lastPositions.get(controller);
                if (positions && positions.length >= 2) {
                    const velocity = new THREE.Vector3();
                    velocity.subVectors(positions[2], positions[0]);
                    velocity.multiplyScalar(30); // Scale for throw strength
                    
                    ball.userData.velocity.copy(velocity);
                    
                    // Calculate and display speed in MPH
                    const speedMS = velocity.length();
                    const speedMPH = speedMS * metersToMiles;
                    console.log(`Throw speed: ${speedMPH.toFixed(1)} MPH`);
                }
                
                heldBalls.delete(controller);
                lastPositions.delete(controller);
            }
        }

        function updatePhysics(delta) {
            balls.forEach(ball => {
                if (ball.userData.held) {
                    // Ball is being held - follow controller
                    for (let [controller, heldBall] of heldBalls) {
                        if (heldBall === ball) {
                            ball.position.copy(controller.position);
                            
                            // Track position history for velocity calculation
                            let positions = lastPositions.get(controller);
                            if (positions) {
                                positions.shift();
                                positions.push(controller.position.clone());
                            }
                        }
                    }
                } else {
                    // Apply physics
                    ball.userData.velocity.y += gravity * delta;
                    
                    ball.position.x += ball.userData.velocity.x * delta;
                    ball.position.y += ball.userData.velocity.y * delta;
                    ball.position.z += ball.userData.velocity.z * delta;
                    
                    // Ground collision
                    if (ball.position.y < 0.1) {
                        ball.position.y = 0.1;
                        ball.userData.velocity.y *= -0.7; // Bounce with energy loss
                        ball.userData.velocity.x *= 0.95; // Friction
                        ball.userData.velocity.z *= 0.95;
                        
                        // Stop if moving slowly
                        if (Math.abs(ball.userData.velocity.y) < 0.1) {
                            ball.userData.velocity.y = 0;
                        }
                    }
                    
                    // Remove balls that fall off
                    if (ball.position.y < -10) {
                        scene.remove(ball);
                        balls = balls.filter(b => b !== ball);
                    }
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        let lastTime = 0;
        function render(time) {
            const delta = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;
            
            updatePhysics(delta);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
